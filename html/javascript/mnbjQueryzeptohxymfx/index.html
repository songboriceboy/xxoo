<!DOCTYPE html>

<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta name="description" content="android,ios" />
        <meta name="keywords" content="android,ios" />

        <title>叶小钗</title>
        <style type='text/css'>
            body {
                background-color: #CCC;
            }
        </style>
        <link rel="stylesheet" href="../../../css/bootstrap.css" />
    </head>

    <body>
        <div class="container">

            <h1>叶小钗</h1>

            <div class='navbar navbar-inverse'>
                <div class='navbar-inner nav-collapse' style="height: auto;">
                    <ul class="nav">
                              				<li><a href="http://songboriceboy.github.io/xxoo/html/blade/index.html">blade</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/css/index.html">css</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/HTML5&CSS3/index.html">HTML5&CSS3</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/index.html">javascript</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/Javaxx/index.html">Java学习</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/nodejs/index.html">nodejs</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/requirejs/index.html">requirejs</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/Webqd/index.html">Web前端</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/xxgw/index.html">学习感悟</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/gzdd/index.html">工作点滴</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/jkxx/index.html">接口学习</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/wfl/index.html">未分类</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/ydkf/index.html">移动开发</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/sjms/index.html">设计模式</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/mst/index.html">面试题</a></li>
    				                      </ul>
                </div>
            </div>

            <div id='content' class='row-fluid'>

                <div class='span9 main'>
				<div style="color:blue" align=center>迷你版jQuery——zepto核心源码分析</div><br><h1>前言</h1>
<div>zepto号称迷你版jQuery，并且成为移动端dom操作库的首选</div>
<div>事实上zepto很多时候只是借用了jQuery的名气，保持了与其基本一致的API，其内部实现早已面目全非！</div>
<div>艾伦分析了jQuery，小钗暂时没有那个本事分析jQuery，这里就恬不知耻说说自己对zepto的源码理解，希望对各位有用</div>
<div>首先zepto的出现其实还是很讨巧的，他看见了巨人jQuery在移动浪潮来临时的转身慢、牵挂多的问题</div>
<div>马上搞出了一套轻量级类jQuery框架代码，核心代码1000行不到，快速占领了移动端的市场，所以天下武学无坚不摧，为快不破啊！！！</div>
<div>也如艾伦所言，jQuery狭义的讲其实就是dom操作库</div>
<div>zepto将这点发扬光大，并且抛弃了浏览器兼容的包袱，甚至CSS3的前缀都不给加，这些因素造就了zepto小的事实，于是我们开始学习他吧</div>
<div>此文只是个人对zepto的粗浅理解，有误请提出</div>
<h1>核心组成</h1>
<div>zepto现在也采用了模块拆分，这样读起来其实代码十分清晰，门槛也低了很多，整个zepto核心模块保持在900行以内</div>
<div>我们说他很好的发扬了dom库特点便是因为这900行基本在干dom操作的活</div>
<div>
<div>核心模块有以下部分组成：</div>
<h3>① 闭包变量、工具类方法定义</h3>
<div>这个部分主要为后面服务，比如说什么isFunction/isPlainObject/children</div>
<div>其中有一个比较特别的变量是</div>
<div>
<div class="cnblogs_code">
<pre>zepto = {};</pre>
</div>
<p><span style="line-height: 1.5;">这个变量贯穿始终，也是zepto与jQuery很不一样的地方，jQuery是一个类，会创建一个个实例，而zepto本身就只是一个对象......</span></p>
</div>
<h3>② zepto与jQuery的$</h3>
<div>zepto第二阶段干的事情便是定义了一个类</div>
<div>
<div class="cnblogs_code">
<pre>$ = <span style="color: #0000ff;">function</span><span style="color: #000000;">(selector, context){
  </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> zepto.init(selector, context)
}</span></pre>
</div>
<p><span style="line-height: 1.5;">而我们开始便说了zepto只是一个对象，而zepto.init也仅仅是返回了一个类数组的东西，于是我们这里便看到了zepto与jQuery的惊人差异</span></p>
</div>
<div>第一观感是zepto没有类操作！我们使用$('')的操作返回的也是zepto的实例</div>
<div>$对于zepto来说仅仅是一个方法，zepto却使用了非正规手法返回了实例......</div>
</div>
<div><img src="41381527171901.png" alt=""></div>
<div><img src="362417410440919.png" alt=""></div>
<div>从这里看整个zepto其实和jQuery就差距大了，zepto的$方法返回了一个Object的实例，而jQuery的$返回的是真资格的jQuery对象</div>
<div>而从后面看其实zepto也是返回的一个实例但是与jQuery的实现有所不同，那么zepto是怎么实现实例返回的呢？</div>
<h3>③ zepto与jQuery的$.fn</h3>
<div>我们知道jQuery的$.fn指向的是jQuery.prototype的原型对象，而zepto的fn就是一个简单对象</div>
<div>
<div class="cnblogs_code">
<pre>$.fn = {};</pre>
</div>
<div>zepto的第三部分便是扩展$函数，我们使用的$的方法事实上都是其静态方法，与原型链一毛钱关系都没有</div>
<div>以上便是zepto核心模块的实现，很干净的实现，仅仅是dom操作，不涉及事件或者Ajax操作，简单来说zepto的实现是这个样子的</div>
</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">var</span> zepto =<span style="color: #000000;"> {}, $;
</span><span style="color: #008080;"> 2</span>      
<span style="color: #008080;"> 3</span> zepto.init = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (selector, context) {
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">var</span> domArr =<span style="color: #000000;"> [];
</span><span style="color: #008080;"> 5</span>   <span style="color: #008000;">//</span><span style="color: #008000;">这个__proto__是系统级变量，我觉得zepto不该重置 ，但是不重置的话实例便找不到方法了！！！</span>
<span style="color: #008080;"> 6</span>   domArr.__proto__ =<span style="color: #000000;"> $.fn
</span><span style="color: #008080;"> 7</span>   domArr.selector =<span style="color: #000000;"> selector;
</span><span style="color: #008080;"> 8</span>   <span style="color: #008000;">//</span><span style="color: #008000;">一些列操作</span>
<span style="color: #008080;"> 9</span>   <span style="color: #0000ff;">return</span><span style="color: #000000;"> domArr;
</span><span style="color: #008080;">10</span> <span style="color: #000000;">};
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span> $ = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (selector, context) {
</span><span style="color: #008080;">13</span>   <span style="color: #0000ff;">return</span><span style="color: #000000;"> zepto.init(selector, context);
</span><span style="color: #008080;">14</span> <span style="color: #000000;">};
</span><span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span> $.fn =<span style="color: #000000;"> {
</span><span style="color: #008080;">17</span>   addClass: <span style="color: #0000ff;">function</span><span style="color: #000000;"> () { },
</span><span style="color: #008080;">18</span>   attr: <span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
</span><span style="color: #008080;">19</span> };</pre>
</div>
<p>这里有段非常关键的代码是：</p>
</div>
<div>
<div class="cnblogs_code">
<pre>domArr.__proto__ = $.fn；</pre>
</div>
<div>如果是没有这段代码的话， domArr便是属于array的实例，便不能使用$.fn中的方法了，但是他这里重置了__proto__的指向所以就能用了</div>
<div>PS：由于IE是不认这个属性的，所以IE必定会报错</div>
<div>由于这里的改下，本来domArr也会有一些变化：</div>
</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #000000;">dom.__proto__.constructor
</span><span style="color: #008080;"> 2</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> Array() { [native code] }
</span><span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> <span style="color: #000000;">dom.__proto__.constructor
</span><span style="color: #008080;"> 5</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> Object() { [native code] }
</span><span style="color: #008080;"> 6</span> 
<span style="color: #008080;"> 7</span> zepto.Z = <span style="color: #0000ff;">function</span><span style="color: #000000;">(dom, selector) {
</span><span style="color: #008080;"> 8</span>   dom = dom ||<span style="color: #000000;"> []
</span><span style="color: #008080;"> 9</span>   dom.__proto__ =<span style="color: #000000;"> $.fn
</span><span style="color: #008080;">10</span>   dom.selector = selector || ''
<span style="color: #008080;">11</span>   <span style="color: #0000ff;">return</span><span style="color: #000000;"> dom
</span><span style="color: #008080;">12</span> <span style="color: #000000;">}
</span><span style="color: #008080;">13</span> <span style="color: #008000;">//</span><span style="color: #008000;">最后加上一句：</span>
<span style="color: #008080;">14</span> zepto.Z.prototype = $.fn</pre>
</div>
<div>如此一来，我们所有的$方法返回的东西其实就变成了zepto.Z的实例了，这里的实现原理其实也有点绕口：</div>
<div>构造函数zepto.Z 包含一个原型 $.fn（zepto.Z的prototype被重写了）</div>
<div>原型$.fn具有一个Constructor回值构造函数zepto.Z（这里由于其粗暴的干法其实直接指向了Object，这里关系其实已经丢失）</div>
<div>比较不正经的是居然是通过重写__proto__实现，感觉怪怪的，好了核心模块介绍结束，我们便进入入口函数的解析了</div>
<h2>分解$方法</h2>
</div>
<div>
<div>$是zepto的入口，具有两个参数selector选择器与context选择范围，这里看着是两个参数，事实上各个参数不同会造成不同的实现</div>
<div>$方法相当于一个黑盒子，用户会根据自己的想法获得自己想要的结果，这也会导致$的实现变得复杂：</div>
</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> $('div'<span style="color: #000000;">);
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">//</span><span style="color: #008000;">=&gt; all DIV elements on the page</span>
<span style="color: #008080;"> 3</span> $('#foo'<span style="color: #000000;">);
</span><span style="color: #008080;"> 4</span> <span style="color: #008000;">//</span><span style="color: #008000;">=&gt; element with ID "foo"</span>
<span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> <span style="color: #008000;">//</span><span style="color: #008000;"> create element:</span>
<span style="color: #008080;"> 7</span> $("&lt;p&gt;Hello&lt;/p&gt;"<span style="color: #000000;">);
</span><span style="color: #008080;"> 8</span> <span style="color: #008000;">//</span><span style="color: #008000;">=&gt; the new P element</span>
<span style="color: #008080;"> 9</span> <span style="color: #008000;">//</span><span style="color: #008000;"> create element with attributes:</span>
<span style="color: #008080;">10</span> $("&lt;p /&gt;"<span style="color: #000000;">, {
</span><span style="color: #008080;">11</span>   text: "Hello"<span style="color: #000000;">,
</span><span style="color: #008080;">12</span>   id: "greeting"<span style="color: #000000;">,
</span><span style="color: #008080;">13</span>   css: { color: 'darkblue'<span style="color: #000000;"> }
</span><span style="color: #008080;">14</span> <span style="color: #000000;">});
</span><span style="color: #008080;">15</span> <span style="color: #008000;">//</span><span style="color: #008000;">=&gt; &lt;p id=greeting style="color:darkblue"&gt;Hello&lt;/p&gt;</span>
<span style="color: #008080;">16</span> 
<span style="color: #008080;">17</span> <span style="color: #008000;">//</span><span style="color: #008000;"> execute callback when the page is ready:</span>
<span style="color: #008080;">18</span> $(<span style="color: #0000ff;">function</span><span style="color: #000000;"> ($) {
</span><span style="color: #008080;">19</span>   alert('Ready to Zepto!'<span style="color: #000000;">)
</span><span style="color: #008080;">20</span> });</pre>
</div>
<p>我们现在来分析其每一种实现</p>
</div>
<div>
<h3>选择器</h3>
<div>zepto主要干的事情还是做dom选择，这里包括标签选择、id选择、类选择等，少了sizzle的复杂，直接使用了querySelectorAll的实现真的很偷懒</div>
<div>PS：同一个页面出现相关相同id的话querySelectorAll会出BUG，这个大家要小心处理！！！</div>
<div>这里筛选的流程是：</div>
<div>① 执行$(selector)方法</div>
<div>② 执行zepto.init(selector)方法，init里面的逻辑就有点小复杂了</div>
<div>判断selector是不是一个字符串，这里需要是干净的字符串，并且context为undefined（这里差距不大，了不起是查找范围的问题）</div>
<div>③ 经过上述逻辑处理，高高兴兴进入zepto.qsa(document, selector)逻辑</div>
<div>这里的逻辑比较简单直接调用判断下选择器的类型（id/class/标签）就直接使用对应的方法获取元素即可</div>
<div>
<div class="cnblogs_code" onclick="cnblogs_code_show('496fe478-eaa9-4bd4-9870-4b43d326b662')"><img id="code_img_closed_496fe478-eaa9-4bd4-9870-4b43d326b662" class="code_img_closed" src="43570758473519.gif" alt=""><img id="code_img_opened_496fe478-eaa9-4bd4-9870-4b43d326b662" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('496fe478-eaa9-4bd4-9870-4b43d326b662',event)" src="16365178109279.gif" alt="">
<div id="cnblogs_code_open_496fe478-eaa9-4bd4-9870-4b43d326b662" class="cnblogs_code_hide">
<pre>zepto.qsa = <span style="color: #0000ff;">function</span><span style="color: #000000;">(element, selector){
  </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> found,
      maybeID </span>= selector[0] == '#'<span style="color: #000000;">,
      maybeClass </span>= !maybeID &amp;&amp; selector[0] == '.'<span style="color: #000000;">,
      nameOnly </span>= maybeID || maybeClass ? selector.slice(1) : selector, <span style="color: #008000;">//</span><span style="color: #008000;"> Ensure that a 1 char tag name still gets checked</span>
      isSimple =<span style="color: #000000;"> simpleSelectorRE.test(nameOnly)
  </span><span style="color: #0000ff;">return</span> (isDocument(element) &amp;&amp; isSimple &amp;&amp; maybeID) ?<span style="color: #000000;">
    ( (found </span>= element.getElementById(nameOnly)) ?<span style="color: #000000;"> [found] : [] ) :
    (element.nodeType </span>!== 1 &amp;&amp; element.nodeType !== 9) ?<span style="color: #000000;"> [] :
    slice.call(
      isSimple </span>&amp;&amp; !maybeID ?<span style="color: #000000;">
        maybeClass </span>? element.getElementsByClassName(nameOnly) : <span style="color: #008000;">//</span><span style="color: #008000;"> If it's simple, it could be a class</span>
        element.getElementsByTagName(selector) : <span style="color: #008000;">//</span><span style="color: #008000;"> Or a tag</span>
        element.querySelectorAll(selector) <span style="color: #008000;">//</span><span style="color: #008000;"> Or it's not simple, and we need to query all</span>
<span style="color: #000000;">    )
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h3>创建元素</h3>
</div>
</div>
<div>$方法的第二大功能便是创建元素了，比如我们这里的</div>
<div>
<div class="cnblogs_code">
<pre>$("&lt;p&gt;Hello&lt;/p&gt;");</pre>
</div>
<p>这里依旧会经过zepto.init的处理，判断是否具有尖括号(&lt;)，有的话便会进入神奇的fragment逻辑创建文档碎片</p>
<div class="cnblogs_code">
<pre>dom = zepto.fragment(selector, RegExp.$1, context)</pre>
</div>
<div>这里有一个正则表达式对传入的html进行解析，目标是标签名</div>
<div>PS：zepto对p标签的解析也会出问题，不建议使用</div>
</div>
<div>
<div class="cnblogs_code">
<pre>zepto.fragment = <span style="color: #0000ff;">function</span>(html, name, properties) {}</pre>
</div>
<p>到fragment方法时，会传入html和那么并且会有相关属性，但是我们一般不这样干，仅仅希望创建DOM</p>
</div>
<div>
<div class="cnblogs_code" onclick="cnblogs_code_show('a97a22a1-3269-4537-a60e-437c6fc36d31')"><img id="code_img_closed_a97a22a1-3269-4537-a60e-437c6fc36d31" class="code_img_closed" src="43570758473519.gif" alt=""><img id="code_img_opened_a97a22a1-3269-4537-a60e-437c6fc36d31" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('a97a22a1-3269-4537-a60e-437c6fc36d31',event)" src="16365178109279.gif" alt="">
<div id="cnblogs_code_open_a97a22a1-3269-4537-a60e-437c6fc36d31" class="cnblogs_code_hide">
<pre>zepto.fragment = <span style="color: #0000ff;">function</span><span style="color: #000000;">(html, name, properties) {
  </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> dom, nodes, container

  </span><span style="color: #008000;">//</span><span style="color: #008000;"> A special case optimization for a single tag</span>
  <span style="color: #0000ff;">if</span> (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1<span style="color: #000000;">))

  </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">dom) {
    </span><span style="color: #0000ff;">if</span> (html.replace) html = html.replace(tagExpanderRE, "&lt;$1&gt;&lt;/$2&gt;"<span style="color: #000000;">)
    </span><span style="color: #0000ff;">if</span> (name === undefined) name = fragmentRE.test(html) &amp;&amp; RegExp.$1
    <span style="color: #0000ff;">if</span> (!(name <span style="color: #0000ff;">in</span> containers)) name = '*'<span style="color: #000000;">

    container </span>=<span style="color: #000000;"> containers[name]
    container.innerHTML </span>= '' +<span style="color: #000000;"> html
    dom </span>= $.each(slice.call(container.childNodes), <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
      container.removeChild(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">)
    })
  }

  </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (isPlainObject(properties)) {
    nodes </span>=<span style="color: #000000;"> $(dom)
    $.each(properties, </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(key, value) {
      </span><span style="color: #0000ff;">if</span> (methodAttributes.indexOf(key) &gt; -1<span style="color: #000000;">) nodes[key](value)
      </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> nodes.attr(key, value)
    })
  }

  </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dom
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<div>里面的逻辑各位自己去看，我这里不多说了，还是很简单的，大概的想法是</div>
<div>创建一个空的div元素，将字符串装载，然后遍历div的子元素，最后返回一个node的集合数组，这个也就是我们实际需要的......</div>
<div>这个样子，创建标签或者selector选择器得到的结果是一致的</div>
<div>其它逻辑大同小异，我们直接就过了，zepto核心入口逻辑就到此结束了......</div>
</div>
<h2>fn的实现</h2>
<div>fn中包含了zepto的很多功能，要一一说明就多了去了，首先由$扩展开始说</div>
<div>除了原型扩展外还为$包含了很多静态方法，比如什么uuid，isFunction，然后就开始了原型链扩展之路</div>
<div>$.fn与zepto.Z.prototype指向的是同一空间，这里达到了是扩展原型链的效果</div>
<div><img src="522336716171.png" alt=""></div>
<div>这里抽2个常用API来看看，比如这里的attr</div>
<div>
<div class="cnblogs_code">
<pre>attr: <span style="color: #0000ff;">function</span><span style="color: #000000;">(name, value){
  </span><span style="color: #0000ff;">var</span><span style="color: #000000;"> result
  </span><span style="color: #0000ff;">return</span> (<span style="color: #0000ff;">typeof</span> name == 'string' &amp;&amp; value === undefined) ?<span style="color: #000000;">
    (</span><span style="color: #0000ff;">this</span>.length == 0 || <span style="color: #0000ff;">this</span>[0].nodeType !== 1 ?<span style="color: #000000;"> undefined :
      (name </span>== 'value' &amp;&amp; <span style="color: #0000ff;">this</span>[0].nodeName == 'INPUT') ? <span style="color: #0000ff;">this</span><span style="color: #000000;">.val() :
      (</span>!(result = <span style="color: #0000ff;">this</span>[0].getAttribute(name)) &amp;&amp; name <span style="color: #0000ff;">in</span> <span style="color: #0000ff;">this</span>[0]) ? <span style="color: #0000ff;">this</span>[0<span style="color: #000000;">][name] : result
    ) :
    </span><span style="color: #0000ff;">this</span>.each(<span style="color: #0000ff;">function</span><span style="color: #000000;">(idx){
      </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.nodeType !== 1) <span style="color: #0000ff;">return</span>
      <span style="color: #0000ff;">if</span> (isObject(name)) <span style="color: #0000ff;">for</span> (key <span style="color: #0000ff;">in</span> name) setAttribute(<span style="color: #0000ff;">this</span><span style="color: #000000;">, key, name[key])
      </span><span style="color: #0000ff;">else</span> setAttribute(<span style="color: #0000ff;">this</span>, name, funcArg(<span style="color: #0000ff;">this</span>, value, idx, <span style="color: #0000ff;">this</span><span style="color: #000000;">.getAttribute(name)))
    })
},
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> setAttribute(node, name, value) {
  value </span>== <span style="color: #0000ff;">null</span> ?<span style="color: #000000;"> node.removeAttribute(name) : node.setAttribute(name, value)
}</span></pre>
</div>
<div>我们看到他这里直接将其转换为了元素DOM操作，没有什么好说的，只是如果value不为undefined时，里面有一个循环为属性赋值的动作</div>
<div>再看这里的html接口</div>
</div>
<div>
<div class="cnblogs_code">
<pre>html: <span style="color: #0000ff;">function</span><span style="color: #000000;">(html){
  </span><span style="color: #0000ff;">return</span> arguments.length === 0 ?<span style="color: #000000;">
    (</span><span style="color: #0000ff;">this</span>.length &gt; 0 ? <span style="color: #0000ff;">this</span>[0].innerHTML : <span style="color: #0000ff;">null</span><span style="color: #000000;">) :
    </span><span style="color: #0000ff;">this</span>.each(<span style="color: #0000ff;">function</span><span style="color: #000000;">(idx){
      </span><span style="color: #0000ff;">var</span> originHtml = <span style="color: #0000ff;">this</span><span style="color: #000000;">.innerHTML
      $(</span><span style="color: #0000ff;">this</span>).empty().append( funcArg(<span style="color: #0000ff;">this</span><span style="color: #000000;">, html, idx, originHtml) )
    })
},
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> funcArg(context, arg, idx, payload) {
  </span><span style="color: #0000ff;">return</span> isFunction(arg) ?<span style="color: #000000;"> arg.call(context, idx, payload) : arg
}</span></pre>
</div>
<div>这里其实是先将this清空，然后装载新的dom结构，这里与设置innerHTML有所不同，append会执行其中的js，设置innerHTML不会执行</div>
<div>剩下的接口有兴趣的朋友自己去看吧，zepto这里实现还是比较简单的。</div>
<div>这里值得一说的是，一些API你直接去看可能看不懂，这个时候就动手写写，实现相同的功能，然后对代码进行重构，最后重构下来代码和他写的就差不多了，这里并不是代码难，而是他那种写法不太好看。</div>
<h1>事件实现</h1>
</div>
<div>
<div>一个稍微成熟点的框架或者说稍微成熟点的团队，一般会对原生的一些东西进行封装，原因是他们可能需要扩展非常典型的例子便是事件与settimeout</div>
<div>以setTimeout为例，在webapp中每次view的切换应该清理所有的settimeout，但是我们知道clearTimeout()是必须传入id的，所以我们不能这么干</div>
<div>现在回到javascript事件这块，最初事件的出现可能仅仅是为了做浏览器兼容</div>
<div>那么现在我们依旧会使用zepto提供的事件主要原因就是其扩展的一些功能，比如委托与命名空间等，最重要的还是事件句柄移除</div>
<div>
<div>javascript事件的移除很是严苛，要求必须与之一致的参数，比如：</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #000000;">el.addEventListerner(type, fn, capture);
el.removeEventListerner(type, fn, capture);</span></pre>
</div>
<p><span style="line-height: 1.5;">两者参数需要完全一致，而我们的fn很多时候就是个匿名函数甚至是对象，很多时候定义后句柄引用就丢了，我们根本没法将其保持一致</span></p>
</div>
<div>这个时候这个句柄便无法释放，所以我们需要对事件进行封装，我们这里便进入zepto event的实现，学习这个还是看入口点</div>
<h2>事件注册</h2>
<p>简单来说使用zepto绑定事件一般是这样：</p>
<div>① $.on(type, fn)</div>
<div>② $.bind(type, fn)</div>
<div>③ $.click(fn)</div>
<div>④ ......</div>
<div>事实上，这些方式差距不大，特别是第二种只是做了一个语法糖，比如：</div>
<div class="cnblogs_code">
<pre>$.click = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (fn) {
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.bind('click'<span style="color: #000000;">, fn);
}</span></pre>
</div>
<p>事实上他还是调用的$.bind实现事件绑定，换个思维方式，其实整个zepto事件实现可以浓缩成这么几句话：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> eventSet =<span style="color: #000000;"> {
    el: {fnType: []}
};
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> on(type, fn) {}
</span><span style="color: #0000ff;">function</span> off(type, fn) {}</pre>
</div>
<div>这个便是zepto事件核心代码......当然这里还差了一个trigger，这里便是与传统自建系统不一样的地方，他的触发是通过浏览器处理</div>
<div>这个是一个标准的发布订阅系统，我们对浏览器的操作会生产事件，这个时候浏览器会根据我们的行为通知对应的事件接收者处理事件</div>
<div>所有的绑定最终调用的皆是$.on，而on或者off的最终归宿为局部闭包add和remove方法</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('5b40e2a8-9202-4396-9382-25256b46e8db')"><img id="code_img_closed_5b40e2a8-9202-4396-9382-25256b46e8db" class="code_img_closed" src="43570758473519.gif" alt=""><img id="code_img_opened_5b40e2a8-9202-4396-9382-25256b46e8db" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5b40e2a8-9202-4396-9382-25256b46e8db',event)" src="16365178109279.gif" alt="">
<div id="cnblogs_code_open_5b40e2a8-9202-4396-9382-25256b46e8db" class="cnblogs_code_hide">
<pre>$.fn.on = <span style="color: #0000ff;">function</span><span style="color: #000000;">(event, selector, data, callback, one){
  </span><span style="color: #0000ff;">var</span> autoRemove, delegator, $<span style="color: #0000ff;">this</span> = <span style="color: #0000ff;">this</span>
  <span style="color: #0000ff;">if</span> (event &amp;&amp; !<span style="color: #000000;">isString(event)) {
    $.each(event, </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(type, fn){
      $</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.on(type, selector, data, fn, one)
    })
    </span><span style="color: #0000ff;">return</span> $<span style="color: #0000ff;">this</span><span style="color: #000000;">
  }

  </span><span style="color: #0000ff;">if</span> (!isString(selector) &amp;&amp; !isFunction(callback) &amp;&amp; callback !== <span style="color: #0000ff;">false</span><span style="color: #000000;">)
    callback </span>= data, data = selector, selector =<span style="color: #000000;"> undefined
  </span><span style="color: #0000ff;">if</span> (isFunction(data) || data === <span style="color: #0000ff;">false</span><span style="color: #000000;">)
    callback </span>= data, data =<span style="color: #000000;"> undefined

  </span><span style="color: #0000ff;">if</span> (callback === <span style="color: #0000ff;">false</span>) callback =<span style="color: #000000;"> returnFalse

  </span><span style="color: #0000ff;">return</span> $<span style="color: #0000ff;">this</span>.each(<span style="color: #0000ff;">function</span><span style="color: #000000;">(_, element){
    </span><span style="color: #0000ff;">if</span> (one) autoRemove = <span style="color: #0000ff;">function</span><span style="color: #000000;">(e){
      remove(element, e.type, callback)
      </span><span style="color: #0000ff;">return</span> callback.apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments)
    }

    </span><span style="color: #0000ff;">if</span> (selector) delegator = <span style="color: #0000ff;">function</span><span style="color: #000000;">(e){
      </span><span style="color: #0000ff;">var</span> evt, match = $(e.target).closest(selector, element).get(0<span style="color: #000000;">)
      </span><span style="color: #0000ff;">if</span> (match &amp;&amp; match !==<span style="color: #000000;"> element) {
        evt </span>=<span style="color: #000000;"> $.extend(createProxy(e), {currentTarget: match, liveFired: element})
        </span><span style="color: #0000ff;">return</span> (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1<span style="color: #000000;">)))
      }
    }

    add(element, event, callback, data, selector, delegator </span>||<span style="color: #000000;"> autoRemove)
  })
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>这里的event可以是以空格分隔的字符串，一般情况下是单一的事件</p>
<div class="cnblogs_code">
<pre>event =&gt; 'mousedown touchstart'<span style="color: #000000;">
event </span>=&gt; 'click'</pre>
</div>
<div>然后这里开始了处理逻辑：</div>
<div>① 参数处理</div>
<div>第一步当然是做参数处理，会修正参数，比如你没有传事件句柄，这里会给个默认的，然后开始循环绑定，因为我们使用$()返回的是一个数组</div>
<div>进入循环逻辑后，this与element便是真资格的dom元素了，未经雕琢，开始是对one的处理，我们不予关注，继续向下便进入第一个关键点</div>
<div>简单情况下我们的selector为undefined，所以这里错过了一个事件委托的重要逻辑，我们先不予理睬，再往下便进入了闭包方法add了</div>
<div>这个情况下selector与delegator为undefined，仅仅是前3个参数有效</div>
<p><img src="17814065733780.png" alt=""></p>
<p>add在event事件中扮演了重要的角色</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('b67cf301-761e-438d-8c23-09fedb9318df')"><img id="code_img_closed_b67cf301-761e-438d-8c23-09fedb9318df" class="code_img_closed" src="43570758473519.gif" alt=""><img id="code_img_opened_b67cf301-761e-438d-8c23-09fedb9318df" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b67cf301-761e-438d-8c23-09fedb9318df',event)" src="16365178109279.gif" alt="">
<div id="cnblogs_code_open_b67cf301-761e-438d-8c23-09fedb9318df" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> add(element, events, fn, data, selector, delegator, capture){
  </span><span style="color: #0000ff;">var</span> id = zid(element), set = (handlers[id] || (handlers[id] =<span style="color: #000000;"> []))
  events.split(</span>/\s/).forEach(<span style="color: #0000ff;">function</span><span style="color: #000000;">(event){
    </span><span style="color: #0000ff;">if</span> (event == 'ready') <span style="color: #0000ff;">return</span><span style="color: #000000;"> $(document).ready(fn)
    </span><span style="color: #0000ff;">var</span> handler =<span style="color: #000000;"> parse(event)
    handler.fn </span>=<span style="color: #000000;"> fn
    handler.sel </span>=<span style="color: #000000;"> selector
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> emulate mouseenter, mouseleave</span>
    <span style="color: #0000ff;">if</span> (handler.e <span style="color: #0000ff;">in</span> hover) fn = <span style="color: #0000ff;">function</span><span style="color: #000000;">(e){
      </span><span style="color: #0000ff;">var</span> related =<span style="color: #000000;"> e.relatedTarget
      </span><span style="color: #0000ff;">if</span> (!related || (related !== <span style="color: #0000ff;">this</span> &amp;&amp; !$.contains(<span style="color: #0000ff;">this</span><span style="color: #000000;">, related)))
        </span><span style="color: #0000ff;">return</span> handler.fn.apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments)
    }
    handler.del </span>=<span style="color: #000000;"> delegator
    </span><span style="color: #0000ff;">var</span> callback = delegator ||<span style="color: #000000;"> fn
    handler.proxy </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(e){
      e </span>=<span style="color: #000000;"> compatible(e)
      </span><span style="color: #0000ff;">if</span> (e.isImmediatePropagationStopped()) <span style="color: #0000ff;">return</span><span style="color: #000000;">
      e.data </span>=<span style="color: #000000;"> data
      </span><span style="color: #0000ff;">var</span> result = callback.apply(element, e._args == undefined ?<span style="color: #000000;"> [e] : [e].concat(e._args))
      </span><span style="color: #0000ff;">if</span> (result === <span style="color: #0000ff;">false</span><span style="color: #000000;">) e.preventDefault(), e.stopPropagation()
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> result
    }
    handler.i </span>=<span style="color: #000000;"> set.length
    set.push(handler)
    </span><span style="color: #0000ff;">if</span> ('addEventListener' <span style="color: #0000ff;">in</span><span style="color: #000000;"> element)
      element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))
  })
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>第一段代码就很重要：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> id =<span style="color: #000000;"> zid(element)
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> zid(element) {
  </span><span style="color: #0000ff;">return</span> element._zid || (element._zid = _zid++<span style="color: #000000;">)
}</span></pre>
</div>
<p>这里的zid非常关键，这里的element为与原生对象，这里在上面加了一个_zid的属性，这个属性会跟随其由始至终，不会丢失，如果是zepto封装的dom对象的话，就很容易丢失，因为每次根据$()创建的dom都是新的，这个_zid放到原生属性上是很有意义的</p>
<div>第二个变量也很关键：</div>
<div>
<div class="cnblogs_code">
<pre>set = (handlers[id] || (handlers[id] = []))</pre>
</div>
<p><span style="line-height: 1.5;">我们所有绑定的事件以_zid为键值放在了外部闭包环境handlers对象中，每一个id对应的为一个数组，这个与绑定先后顺序相关</span></p>
</div>
<div>然后进入具体绑定逻辑：</div>
<div>完了这里会考虑是'mousedwon touchstart'的情况所以会有一个循环，我们这里由于只是click便不予理睬了，ready事件我们也直接忽略，进入逻辑后关键点来了</div>
<div>这里定义了一个handler对象，这个对象会存于handlers里面</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> handler =<span style="color: #000000;"> parse(event)
handler.fn </span>=<span style="color: #000000;"> fn
handler.sel </span>=<span style="color: #000000;"> selector

</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> parse(event) {
  </span><span style="color: #0000ff;">var</span> parts = ('' + event).split('.'<span style="color: #000000;">)
  </span><span style="color: #0000ff;">return</span> {e: parts[0], ns: parts.slice(1).sort().join(' '<span style="color: #000000;">)}
}</span></pre>
</div>
<div>这里会解析event参数，取出其中的命名空间，比如:'click.ui'或者'click.namespace'</div>
<div>返回的对象，第一个是真正绑定的事件Type，第二个是其命名空间：</div>
</div>
<div class="cnblogs_code">
<pre>handler =<span style="color: #000000;"> {
  e: </span>'click'<span style="color: #000000;">,
  ns: </span>''<span style="color: #008000;">//</span><span style="color: #008000;">我这里为null  </span>
}</pre>
</div>
<div>后面再为handler对象扩展fn与selector属性，这里的fn尤其关键！！！</div>
<div>我们知道，绑定时若是使用的是匿名函数的话，其引用会丢失，但是这里就把他保持下来存到了handlers中，为后面off消除句柄提供了条件</div>
<div>下面会有段代码，处理mouse事件，用以模拟mouseenter, mouseleave，我们简单来看看其实现：</div>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> emulate mouseenter, mouseleave</span>
<span style="color: #0000ff;">if</span> (handler.e <span style="color: #0000ff;">in</span> hover) fn = <span style="color: #0000ff;">function</span><span style="color: #000000;">(e){
  </span><span style="color: #0000ff;">var</span> related =<span style="color: #000000;"> e.relatedTarget
  </span><span style="color: #0000ff;">if</span> (!related || (related !== <span style="color: #0000ff;">this</span> &amp;&amp; !$.contains(<span style="color: #0000ff;">this</span><span style="color: #000000;">, related)))
    </span><span style="color: #0000ff;">return</span> handler.fn.apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments)
}
$.contains </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(parent, node) {
  </span><span style="color: #0000ff;">return</span> parent !== node &amp;&amp;<span style="color: #000000;"> parent.contains(node)
}</span></pre>
</div>
<p>relatedTarget 事件属性返回与事件的目标节点相关的节点。<br>对于 mouseover 事件来说，该属性是鼠标指针移到目标节点上时所离开的那个节点。<br>对于 mouseout 事件来说，该属性是离开目标时，鼠标指针进入的节点。<br>对于其他类型的事件来说，这个属性没有用。<br>所以我们使用mouseenter，其实mousemove依旧一直在执行，只不过满足要求才会进入mouseleave绑定的回调</p>
<div>这里结束便进入事件绑定的真正逻辑，这里又为handler新增了一个proxy属性，将真实的事件回调封装了，封装的主要原因是做事件代理，事件代理一块我们先不关注</div>
<div>我们看到proxy将我们的回调fn（已经变成了callback），做一次封装，直接为element注册事件了，其影响会在触发时产生：</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('29f7604e-d77e-4cab-9346-a2ab286ee79c')"><img id="code_img_closed_29f7604e-d77e-4cab-9346-a2ab286ee79c" class="code_img_closed" src="43570758473519.gif" alt=""><img id="code_img_opened_29f7604e-d77e-4cab-9346-a2ab286ee79c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('29f7604e-d77e-4cab-9346-a2ab286ee79c',event)" src="16365178109279.gif" alt="">
<div id="cnblogs_code_open_29f7604e-d77e-4cab-9346-a2ab286ee79c" class="cnblogs_code_hide">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> compatible(event, source) {
  </span><span style="color: #0000ff;">if</span> (source || !<span style="color: #000000;">event.isDefaultPrevented) {
    source </span>|| (source =<span style="color: #000000;"> event)

    $.each(eventMethods, </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(name, predicate) {
      </span><span style="color: #0000ff;">var</span> sourceMethod =<span style="color: #000000;"> source[name]
      event[name] </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
        </span><span style="color: #0000ff;">this</span>[predicate] =<span style="color: #000000;"> returnTrue
        </span><span style="color: #0000ff;">return</span> sourceMethod &amp;&amp;<span style="color: #000000;"> sourceMethod.apply(source, arguments)
      }
      event[predicate] </span>=<span style="color: #000000;"> returnFalse
    })

    </span><span style="color: #0000ff;">if</span> (source.defaultPrevented !== undefined ?<span style="color: #000000;"> source.defaultPrevented :
        </span>'returnValue' <span style="color: #0000ff;">in</span> source ? source.returnValue === <span style="color: #0000ff;">false</span><span style="color: #000000;"> :
        source.getPreventDefault </span>&amp;&amp;<span style="color: #000000;"> source.getPreventDefault())
      event.isDefaultPrevented </span>=<span style="color: #000000;"> returnTrue
  }
  </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> event
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>触发事件时他这里首先会对事件参数event做一次封装返回，首先将三大事件对象进行新增接口</p>
<p><img src="24979886469943.png" alt=""></p>
<div>这里重置的一个原因是处理stopImmediatePropagation不支持的浏览器</div>
<div>然后会执行真正的回调，这里会传入相关参数，并将作用域指向element，于是事件注册到事件定义第一阶段结束</div>
<div>不一样的是事件委托，比如：</div>
<div class="cnblogs_code">
<pre>el1.on('click', '#Div1', <span style="color: #0000ff;">function</span><span style="color: #000000;"> (e) {
  s </span>= ''<span style="color: #000000;">;
});</span></pre>
</div>
<p>具有selector参数后在add处便会处理不一致，会多出一段逻辑将真正的回调重置了</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">if</span> (selector) delegator = <span style="color: #0000ff;">function</span><span style="color: #000000;">(e){
  </span><span style="color: #0000ff;">var</span> evt, match = $(e.target).closest(selector, element).get(0<span style="color: #000000;">)
  </span><span style="color: #0000ff;">if</span> (match &amp;&amp; match !==<span style="color: #000000;"> element) {
    evt </span>=<span style="color: #000000;"> $.extend(createProxy(e), {currentTarget: match, liveFired: element})
    </span><span style="color: #0000ff;">return</span> (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1<span style="color: #000000;">)))
  }
}</span></pre>
</div>
<p>这段代码也很经典，他的影响依旧发生在执行的时候（这里在add中依旧会被再次处理），首先这里比较关键的代码是</p>
<div class="cnblogs_code">
<pre>match = $(e.target).closest(selector, element).get(0)</pre>
</div>
<div>这个会根据当前点击最深节点与selector选择器选择离他最近的parent节点，然后判断是否找到，这里条件还必须满足找到的不是当前元素</div>
<div>如果找到了，会对event参数做一次处理，为其重写currentTarget属性，让他指向与selector相关的节点（这点很关键）</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> createProxy(event) {
  </span><span style="color: #0000ff;">var</span> key, proxy =<span style="color: #000000;"> { originalEvent: event }
  </span><span style="color: #0000ff;">for</span> (key <span style="color: #0000ff;">in</span><span style="color: #000000;"> event)
    </span><span style="color: #0000ff;">if</span> (!ignoreProperties.test(key) &amp;&amp; event[key] !== undefined) proxy[key] =<span style="color: #000000;"> event[key]

  </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> compatible(proxy, event)
}</span></pre>
</div>
<div>这里可以看到，我们如果为document下面的三个元素绑定事件代理，每次点击几次便会执行几次事件，只不过会判断是否进入处理逻辑而已</div>
<div>这里举个div与span的例子，如果父级div（wrapper）下面分别为div和span绑定事件的话</div>
</div>
<div>
<div class="cnblogs_code">
<pre>$('#wrapper').on('click', '#span'<span style="color: #000000;">, fn);
$(</span>'#wrapper').on('click', '#div', fn);</pre>
</div>
<div>这个事实上会为为wrapper绑定两个click事件，我们每次点击wrapper区域都会执行两次click事件，但是是否执行span或者div的事件，要看这里是否点击到了其子节点（e.target）</div>
<div>这里处理结束后会进入add方法，与刚刚的逻辑一致，我们便不予理睬了，只是事件代理的情况下event参数连续被compatible了，而原始的事件句柄也被包裹了两层</div>
</div>
<h2>事件移除</h2>
<div>事件绑定说完，事件移除便比较简单了，入口是off，统一处理存于闭包remove方法中</div>
<div>
<div class="cnblogs_code" onclick="cnblogs_code_show('194dd351-bd8f-42ba-8a4a-d479f8e69681')"><img id="code_img_closed_194dd351-bd8f-42ba-8a4a-d479f8e69681" class="code_img_closed" src="43570758473519.gif" alt=""><img id="code_img_opened_194dd351-bd8f-42ba-8a4a-d479f8e69681" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('194dd351-bd8f-42ba-8a4a-d479f8e69681',event)" src="16365178109279.gif" alt="">
<div id="cnblogs_code_open_194dd351-bd8f-42ba-8a4a-d479f8e69681" class="cnblogs_code_hide">
<pre>$.fn.off = <span style="color: #0000ff;">function</span><span style="color: #000000;">(event, selector, callback){
  </span><span style="color: #0000ff;">var</span> $<span style="color: #0000ff;">this</span> = <span style="color: #0000ff;">this</span>
  <span style="color: #0000ff;">if</span> (event &amp;&amp; !<span style="color: #000000;">isString(event)) {
    $.each(event, </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(type, fn){
      $</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.off(type, selector, fn)
    })
    </span><span style="color: #0000ff;">return</span> $<span style="color: #0000ff;">this</span><span style="color: #000000;">
  }

  </span><span style="color: #0000ff;">if</span> (!isString(selector) &amp;&amp; !isFunction(callback) &amp;&amp; callback !== <span style="color: #0000ff;">false</span><span style="color: #000000;">)
    callback </span>= selector, selector =<span style="color: #000000;"> undefined

  </span><span style="color: #0000ff;">if</span> (callback === <span style="color: #0000ff;">false</span>) callback =<span style="color: #000000;"> returnFalse

  </span><span style="color: #0000ff;">return</span> $<span style="color: #0000ff;">this</span>.each(<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
    remove(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">, event, callback, selector)
  })
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>代码比较简单，可以直接进入remove的逻辑</p>
</div>
<div><img src="21354196169106.png" alt=""></div>
<div>这里有一点值得注意的是，这里的this指向的是原生dom，并且大家注意到里面的_zid，callback或者selector我们一般不使用</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> remove(element, events, fn, selector, capture){
  </span><span style="color: #0000ff;">var</span> id =<span style="color: #000000;"> zid(element)
  ;(events </span>|| '').split(/\s/).forEach(<span style="color: #0000ff;">function</span><span style="color: #000000;">(event){
    findHandlers(element, event, fn, selector).forEach(</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(handler){
      </span><span style="color: #0000ff;">delete</span><span style="color: #000000;"> handlers[id][handler.i]
    </span><span style="color: #0000ff;">if</span> ('removeEventListener' <span style="color: #0000ff;">in</span><span style="color: #000000;"> element)
      element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))
    })
  })
}</span></pre>
</div>
<p>事件注册逻辑复杂，删除却只需要几行，在remove时，这里会根据元素的_zid然后调用findHandlers取出存于闭包handlers里面的事件对象</p>
</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> findHandlers(element, event, fn, selector) {
</span><span style="color: #008080;"> 2</span>   event =<span style="color: #000000;"> parse(event)
</span><span style="color: #008080;"> 3</span>   <span style="color: #0000ff;">if</span> (event.ns) <span style="color: #0000ff;">var</span> matcher =<span style="color: #000000;"> matcherFor(event.ns)
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">return</span> (handlers[zid(element)] || []).filter(<span style="color: #0000ff;">function</span><span style="color: #000000;">(handler) {
</span><span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">return</span><span style="color: #000000;"> handler
</span><span style="color: #008080;"> 6</span>       &amp;&amp; (!event.e || handler.e ==<span style="color: #000000;"> event.e)
</span><span style="color: #008080;"> 7</span>       &amp;&amp; (!event.ns ||<span style="color: #000000;"> matcher.test(handler.ns))
</span><span style="color: #008080;"> 8</span>       &amp;&amp; (!fn || zid(handler.fn) ===<span style="color: #000000;"> zid(fn))
</span><span style="color: #008080;"> 9</span>       &amp;&amp; (!selector || handler.sel ==<span style="color: #000000;"> selector)
</span><span style="color: #008080;">10</span> <span style="color: #000000;">  })
</span><span style="color: #008080;">11</span> }</pre>
</div>
<p>这里有个非常巧妙的地方是我们可以根据之前的namespace取出我们注册的事件集合，比如：</p>
</div>
<div><img src="43585445460087.png" alt=""></div>
<div>findHandlers处理结束便进入最后的的句柄移除操作即可</div>
<div><img src="126729810452478.png" alt=""></div>
<div>
<div>而这里能移除句柄的关键又是在于之前将事件句柄handler.proxy保存下来的原因，至此整个event逻辑结束，值得注意的是element的_zid标识还在，</div>
<div>至于trigger简单来说便是创建一个event事件对象然后dispatch，仅此而已</div>
</div>
<h2>手势处理</h2>
<div>
<div>zepto提供了一个touch库进行手势事件的补充，不得不说其中一个实现很有问题，会造成一些莫名其妙的BUG，但只是以代码实现来说还是很清晰的</div>
<div>zepto的touch库代码约150行，其实现方案是：</div>
<div>在载入zepto后为document绑定touchstart、touchmove、touchend事件，根据手指x、y值的位置判断方向从而触发tap、doubleTap、swipeLeft等事件，这里有几个令人不爽的地方：</div>
<div>① 一旦引入该库便在全局绑定事件，每次点击皆会触发无意义的tap事件</div>
<div>② 若是有人2B的重复引入了zepto事件，那么tap类型事件会触发两次，这个会产生BUG</div>
<div>③ zepto为了实现doubleTap等功能，2B的在touchend时候设置了一个settimeout，然后整个世界都充满翔了</div>
<div>由于setTimeout的抛出主干流程，导致其event参数失效，这个时候就算在tap中执行e.preventDefault()或者什么都是无效的，这个是导致zepto tap&ldquo;点透&rdquo;的罪魁祸首</div>
<div>所以我们若是仅仅为了某块区域的手势功能，完全没有必要引入zepto库，得不偿失的，我们可以以下面代码简单替换，再复杂的功能就没法了：</div>
<div>
<div class="cnblogs_code" onclick="cnblogs_code_show('09e83bc7-9bbf-4503-baf9-61e8476e75c3')"><img id="code_img_closed_09e83bc7-9bbf-4503-baf9-61e8476e75c3" class="code_img_closed" src="43570758473519.gif" alt=""><img id="code_img_opened_09e83bc7-9bbf-4503-baf9-61e8476e75c3" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('09e83bc7-9bbf-4503-baf9-61e8476e75c3',event)" src="16365178109279.gif" alt="">
<div id="cnblogs_code_open_09e83bc7-9bbf-4503-baf9-61e8476e75c3" class="cnblogs_code_hide">
<pre>(<span style="color: #0000ff;">function</span><span style="color: #000000;"> () {

    </span><span style="color: #008000;">//</span><span style="color: #008000;">偏移步长</span>
    <span style="color: #0000ff;">var</span> step = 20<span style="color: #000000;">;

    </span><span style="color: #0000ff;">var</span> touch =<span style="color: #000000;"> {};
    </span><span style="color: #0000ff;">var</span> down = 'touchstart'<span style="color: #000000;">;
    </span><span style="color: #0000ff;">var</span> move = 'touchmove'<span style="color: #000000;">;
    </span><span style="color: #0000ff;">var</span> up = 'touchend'<span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span> (!('ontouchstart' <span style="color: #0000ff;">in</span><span style="color: #000000;"> window)) {
      down </span>= 'mousedown'<span style="color: #000000;">;
      move </span>= 'mousemove'<span style="color: #000000;">;
      up </span>= 'mouseup'<span style="color: #000000;">;
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;">简单借鉴ccd思维做简要处理</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> swipeDirection(x1, x2, y1, y2, sensibility) {

      </span><span style="color: #008000;">//</span><span style="color: #008000;">x移动的步长</span>
      <span style="color: #0000ff;">var</span> _x = Math.abs(x1 -<span style="color: #000000;"> x2);
      </span><span style="color: #008000;">//</span><span style="color: #008000;">y移动步长</span>
      <span style="color: #0000ff;">var</span> _y = Math.abs(y1 -<span style="color: #000000;"> y2);
      </span><span style="color: #0000ff;">var</span> dir = _x &gt;= _y ? (x1 - x2 &gt; 0 ? 'left' : 'right') : (y1 - y2 &gt; 0 ? 'up' : 'down'<span style="color: #000000;">);

      </span><span style="color: #008000;">//</span><span style="color: #008000;">设置灵敏度限制</span>
      <span style="color: #0000ff;">if</span><span style="color: #000000;"> (sensibility) {
        </span><span style="color: #0000ff;">if</span> (dir == 'left' || dir == 'right'<span style="color: #000000;">) {
          </span><span style="color: #0000ff;">if</span> ((_y / _x) &gt; sensibility) dir = ''<span style="color: #000000;">;
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (dir == 'up' || dir == 'down'<span style="color: #000000;">) {
          </span><span style="color: #0000ff;">if</span> ((_x / _y) &gt; sensibility) dir = ''<span style="color: #000000;">;
        }
      }
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dir;
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;">sensibility设置灵敏度，值为0-1</span>
    <span style="color: #0000ff;">function</span><span style="color: #000000;"> flip(el, dir, fn, noDefault, sensibility) {
      </span><span style="color: #0000ff;">if</span> (!el) <span style="color: #0000ff;">return</span><span style="color: #000000;">;

      el.on(down, </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (e) {
        </span><span style="color: #0000ff;">var</span> pos = (e.touches &amp;&amp; e.touches[0]) ||<span style="color: #000000;"> e;
        touch.x1 </span>=<span style="color: #000000;"> pos.pageX;
        touch.y1 </span>=<span style="color: #000000;"> pos.pageY;

      }).on(move, </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (e) {
        </span><span style="color: #0000ff;">var</span> pos = (e.touches &amp;&amp; e.touches[0]) ||<span style="color: #000000;"> e;
        touch.x2 </span>=<span style="color: #000000;"> pos.pageX;
        touch.y2 </span>=<span style="color: #000000;"> pos.pageY;

        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果view过长滑不动是有问题的</span>
        <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">noDefault) { e.preventDefault(); }
      }).on(up, </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (e) {


        </span><span style="color: #0000ff;">if</span> ((touch.x2 &amp;&amp; Math.abs(touch.x1 - touch.x2) &gt; step) ||<span style="color: #000000;">
        (touch.y2 </span>&amp;&amp; Math.abs(touch.y1 - touch.y2) &gt;<span style="color: #000000;"> step)) {
          </span><span style="color: #0000ff;">var</span> _dir =<span style="color: #000000;"> swipeDirection(touch.x1, touch.x2, touch.y1, touch.y2, sensibility);
          </span><span style="color: #0000ff;">if</span> (dir ===<span style="color: #000000;"> _dir) {
            </span><span style="color: #0000ff;">typeof</span> fn == 'function' &amp;&amp;<span style="color: #000000;"> fn();
          }
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
          </span><span style="color: #008000;">//</span><span style="color: #008000;">tap的情况</span>
          <span style="color: #0000ff;">if</span> (dir === 'tap'<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">typeof</span> fn == 'function' &amp;&amp;<span style="color: #000000;"> fn();
          }
        }
      });
    }

    </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> flipDestroy(el) {
      </span><span style="color: #0000ff;">if</span> (!el) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
      el.off(down).off(move).off(up);
    }

    _.flip </span>=<span style="color: #000000;"> flip;
    _.flipDestroy </span>=<span style="color: #000000;"> flipDestroy;

})();</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h1>其它</h1>
</div>
</div>
<div>
<div>累了，略......</div>
<h2>Ajax</h2>
<div><a href="http://www.cnblogs.com/yexiaochai/archive/2013/04/24/3037069.html">http://www.cnblogs.com/yexiaochai/archive/2013/04/24/3037069.html</a></div>
<h2>animate</h2>
<div><a href="http://www.cnblogs.com/yexiaochai/p/3602303.html">http://www.cnblogs.com/yexiaochai/p/3602303.html</a></div>
<h1>结语</h1>
<div>我们今天对zepto做了一个整理性学习，希望对各位有帮助，最后微博求粉！！！</div>
<div><a href="http://weibo.com/yiquinian/home?wvr=5">http://weibo.com/yiquinian/home?wvr=5</a></div>
</div>
</div>
</div>
                </div>

                <div class='span3 sidebar'>
                    <h2>导航栏</h2>
                    <ul class="nav nav-tabs nav-stacked">
                             				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptzdyxhxzsdyjxyzyddf/index.html">javascript中的一些核心知识点以及需要注意的地方</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/[zd]webappdyhzlyzydqdyhdpyjlkkb/index.html">[置顶]【webapp的优化整理】要做移动前端优化的朋友进来看看吧</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/[zd]yddjrwtyjjavascriptsjjzxjsjydjr/index.html">[置顶]【移动端兼容问题研究】javascript事件机制详解（涉及移动兼容）</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/gruntzhb30fzxhsygruntdbqddm/index.html">【grunt整合版】30分钟学会使用grunt打包前端代码</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/gruntdyd30fzxhsygruntdbqddm/index.html">【grunt第一弹】30分钟学会使用grunt打包前端代码</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/gruntdsdgruntzqdsjxmzdyy/index.html">【grunt第三弹】grunt在前端实际项目中的应用</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/gruntded30fzxhsygruntdbqddm02/index.html">【grunt第二弹】30分钟学会使用grunt打包前端代码（02）</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/IScrollsrxxtpyddhadlqs/index.html">【IScroll深入学习】突破移动端黑暗的利器（上）</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/IScrollsrxxjjIScrollynzz/index.html">【IScroll深入学习】解决IScroll疑难杂症</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/iScrollymxx00mniScroll/index.html">【iScroll源码学习00】模拟iScroll</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/iScrollymxx01zbjd/index.html">【iScroll源码学习01】准备阶段</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/iScrollymxx02fjiScrollsghxsjd/index.html">【iScroll源码学习02】分解iScroll三个核心事件点</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/iScrollymxx03iScrollsjjzygdtdsx/index.html">【iScroll源码学习03】iScroll事件机制与滚动条的实现</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/iScrollymxx04flIScrollhx/index.html">【iScroll源码学习04】分离IScroll核心</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptpxdytyyjc/index.html">【javascript培训第一天】语言基础</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptpxdstcybl/index.html">【javascript培训第三天】查遗补漏</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptpxdetDOMyBOM/index.html">【javascript培训第二天】DOM与BOM</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptjzdsk01mkhbc/index.html">【javascript激增的思考01】模块化编程</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptjzdsk02mkhyMVC/index.html">【javascript激增的思考02】模块化与MVC</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptjzdsk03MVVMyKnockout/index.html">【javascript激增的思考03】MVVM与Knockout</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptjzdsk04MVCyBackbonejs(beta)/index.html">【javascript激增的思考04】MVC与Backbonejs(beta)</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptmxdxzlrwmyqltkdzb01/index.html">【javascript面向对象之路】让我们一起来坦克大战吧01</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/NodeJSxxbj04xwfbxt/index.html">【NodeJS学习笔记04】新闻发布系统</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/requireJSymxx01ljzgrequireJSdjg/index.html">【requireJS源码学习01】了解整个requireJS的结构</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/requireJSymxx02datamainjzdsx/index.html">【requireJS源码学习02】datamain加载的实现</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/requireJSymxx03xjrequireJSdjzlc/index.html">【requireJS源码学习03】细究requireJS的加载流程</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/UIcjkfygjdrlcjs/index.html">【UI插件】开发一个简单日历插件（上）</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/UIcjjddrlcjxxxMVCsx/index.html">【UI插件】简单的日历插件（下）——学习MVC思想</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zeptoxxbj01hxff$()/index.html">【zepto学习笔记01】核心方法$()</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zeptoxxbj01hxff$()b/index.html">【zepto学习笔记01】核心方法$()（补）</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zeptoxxbj02lsd/index.html">【zepto学习笔记02】零碎点</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zeptoxxbj03sjjz/index.html">【zepto学习笔记03】事件机制</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ycmsztjavascriptzdjc/index.html">【一次面试】再谈javascript中的继承</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ztbackbone01mxModel/index.html">【再探backbone01】模型Model</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ztbackbone02jhCollection/index.html">【再探backbone02】集合Collection</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ztbackbone03bkydyyysltgym/index.html">【再探backbone03】博客园单页应用实例（提供源码）</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ztbackbone04dyyydjslycl/index.html">【再探backbone04】单页应用的基石路由处理</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ctUnderscorezsmbyq/index.html">【初探Underscore】再说模版引擎</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ckjavascriptamzAjaxjsxnszddAjax/index.html">【初窥javascript奥秘之Ajax】简述下你所知道的Ajax？</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ckjavascriptamzsjmpnxnwmyqmdp/index.html">【初窥javascript奥秘之事件冒泡】那些年我们一起冒的泡</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ckjavascriptamzsjjzldtygdj/index.html">【初窥javascript奥秘之事件机制】论“点透”与“鬼点击”</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ckjavascriptamzrrzmbddthisnzdxzthiszxnlm/index.html">【初窥javascript奥秘之让人捉摸不定的this】你知道现在this指向哪里吗？？？</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ckjavascriptamzbbydxbdhlqbcl/index.html">【初窥javascript奥秘之闭包】叶大侠病都好了，求不踩了：）</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ckjavascriptamzmxdxfzyjc/index.html">【初窥javascript奥秘之面向对象】封装与继承</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/qdmdsjdjgjdnzdljm/index.html">【前端盲点】事件的几个阶段你真的了解么？？？</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dyyyviewymodelxgsl/index.html">【单页应用】view与model相关梳理</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dyyyyqldyyybsxjdwbgns/index.html">【单页应用】一起来单页应用吧，实现简单微博功能！（上）</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dyyyqjkzqappyggxsm/index.html">【单页应用】全局控制器app应该干些什么？</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dyyywmgrhclkjdcccjgx/index.html">【单页应用】我们该如何处理框架弹出层层级关系？</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dyyyljMVC/index.html">【单页应用】理解MVC</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dyyyztxjzviewzjygrhtx/index.html">【单页应用之通信机制】view之间应该如何通信</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dyyyjkzHistoryxsHistorydgdyyydm/index.html">【单页应用巨坑之History】细数History带给单页应用的噩梦</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/xtszeptofindysyjiosdcjpknrnhtt/index.html">【小贴士】zeptofind元素以及ios弹出键盘可能让你很头疼</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/xtsgytransitionEndanimatedygyqgs/index.html">【小贴士】关于transitionEndanimate的一个有趣故事</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/xtsgzzdbbysjwtdzzmp/index.html">【小贴士】工作中的”闭包“与事件委托的”阻止冒泡“</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/xtstytjavascriptzdreplace/index.html">【小贴士】探一探javascript中的replace</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/xtsxnjpyfixeddgydddt/index.html">【小贴士】虚拟键盘与fixed带给移动端的痛！</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ttjavascriptsjjzdcsxyl/index.html">【探讨】javascript事件机制底层实现原理</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/mkhbcljrequireJSsxygjddmkjzq/index.html">【模块化编程】理解requireJS实现一个简单的模块加载器</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zyJavaScriptmfjmtsdqlxkjzbfgndcljz/index.html">【转】【译】JavaScript魔法揭秘探索当前流行框架中部分功能的处理机制</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zxjavascriptgszl01javascriptcszds/index.html">【追寻javascript高手之路01】javascript参数知多少？</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zxjavascriptgszl02blzyyzds/index.html">【追寻javascript高手之路02】变量、作用域知多少？</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zxjavascriptgszl03javascriptdxdld/index.html">【追寻javascript高手之路03】javascript对象大乱斗</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zxjavascriptgszl04ljprototype/index.html">【追寻javascript高手之路04】理解prototype</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zxjavascriptgszl05ljsjl/index.html">【追寻javascript高手之路05】理解事件流</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zgbj04zxzzsj(2)/index.html">【重构笔记04】重新组织数据(2)</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zgbj05jhtjbds/index.html">【重构笔记05】简化条件表达式</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zgbj06jhhsdy/index.html">【重构笔记06】简化函数调用</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ycmshgttbxysjfl/index.html">一次面试回顾——探讨表现与数据分离</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dhzwebappzdxz/index.html">动画在webapp中的现状</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ysandriodlqhthdomclicksjqtsxwttj/index.html">原生andriod浏览器回退后dom（click）事件全体失效问题探究</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/scsbdjxysdsbsjytouchsjdnxs/index.html">手持设备点击响应速度，鼠标事件与touch事件的那些事</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/mnbjQueryzeptohxymfx/index.html">迷你版jQuery——zepto核心源码分析</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dbsgzdlwmlyqxjdddomxzqb/index.html">都别说工资低了，我们来一起写简单的dom选择器吧！</a></li>
    				                                         
                    </ul>
                </div>
            </div>

        </div>
    </body>
</html>