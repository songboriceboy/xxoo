<!DOCTYPE html>

<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta name="description" content="android,ios" />
        <meta name="keywords" content="android,ios" />

        <title>叶小钗</title>
        <style type='text/css'>
            body {
                background-color: #CCC;
            }
        </style>
        <link rel="stylesheet" href="../../../css/bootstrap.css" />
    </head>

    <body>
        <div class="container">

            <h1>叶小钗</h1>

            <div class='navbar navbar-inverse'>
                <div class='navbar-inner nav-collapse' style="height: auto;">
                    <ul class="nav">
                              				<li><a href="http://songboriceboy.github.io/xxoo/html/blade/index.html">blade</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/css/index.html">css</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/HTML5&CSS3/index.html">HTML5&CSS3</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/index.html">javascript</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/Javaxx/index.html">Java学习</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/nodejs/index.html">nodejs</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/requirejs/index.html">requirejs</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/Webqd/index.html">Web前端</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/xxgw/index.html">学习感悟</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/gzdd/index.html">工作点滴</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/jkxx/index.html">接口学习</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/wfl/index.html">未分类</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/ydkf/index.html">移动开发</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/sjms/index.html">设计模式</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/mst/index.html">面试题</a></li>
    				                      </ul>
                </div>
            </div>

            <div id='content' class='row-fluid'>

                <div class='span9 main'>
				<div style="color:blue" align=center>【重构笔记04】重新组织数据(2)</div><br><h1>将单项关联变为双向关联</h1>
<p>有时候，我们两个类需要使用对方属性，但期间只有一条单向连接<br>此时可以添加一个反向指针，并修改关系函数使他能够同时更新两条连接</p>
<p>开发初期，我们可能会在两个类之间建立一条单向连接，使其中一个类可以引用另一个类<br>随着时间推移，我们发现被引用类需要得到其引用者才能进行某些处理，也就是说需要一个反向指针<br>但是指针是一个单向连接，我们不能单向操作他，此时便可以建立双向引用关系了<br>PS：指针好像对js不是很实用的说</p>
<p>这个是我们以后会依赖的创建类的工具类</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">var</span> base =<span style="color: #000000;"> {};
</span><span style="color: #008080;"> 2</span> <span style="color: #0000ff;">var</span> slice =<span style="color: #000000;"> [].slice;
</span><span style="color: #008080;"> 3</span> <span style="color: #0000ff;">var</span> bind = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (scope, fun, args) {
</span><span style="color: #008080;"> 4</span> args = args ||<span style="color: #000000;"> [];
</span><span style="color: #008080;"> 5</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">fun.apply(scope, args.concat(slice.call(arguments)));
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">};
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">};
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span> base.Class = <span style="color: #0000ff;">function</span><span style="color: #000000;"> (supClass, childAttr) {
</span><span style="color: #008080;">11</span> <span style="color: #008000;">//</span><span style="color: #008000;">若是第一个是类，便是继承；如果第一个是对象，第二个参数无意义，便是新建一个类</span>
<span style="color: #008080;">12</span> <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> supClass === 'object'<span style="color: #000000;">) {
</span><span style="color: #008080;">13</span> childAttr =<span style="color: #000000;"> supClass;
</span><span style="color: #008080;">14</span> supClass = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () { };
</span><span style="color: #008080;">15</span> <span style="color: #000000;">}
</span><span style="color: #008080;">16</span> <span style="color: #008000;">//</span><span style="color: #008000;">新建临时类，最后作为新类返回，可能是继承可能是新类</span>
<span style="color: #008080;">17</span> <span style="color: #008000;">/*</span><span style="color: #008000;">**
</span><span style="color: #008080;">18</span> <span style="color: #008000;">这里非常关键，为整个方法的入口，一定得看到初始化后，这里会执行构造函数
</span><span style="color: #008080;">19</span> <span style="color: #008000;">**</span><span style="color: #008000;">*/</span>
<span style="color: #008080;">20</span> <span style="color: #0000ff;">var</span> newClass = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
</span><span style="color: #008080;">21</span> <span style="color: #008000;">//</span><span style="color: #008000;">每个类都会使用该函数，作为第一步初始化，告诉类有哪些属性</span>
<span style="color: #008080;">22</span> <span style="color: #0000ff;">this</span>._propertys_ &amp;&amp; <span style="color: #0000ff;">this</span><span style="color: #000000;">._propertys_();
</span><span style="color: #008080;">23</span> <span style="color: #008000;">//</span><span style="color: #008000;">第二步初始化，相当于子类的构造函数，比较重要，初始化方法不一定会出现</span>
<span style="color: #008080;">24</span> <span style="color: #0000ff;">this</span>.init &amp;&amp; <span style="color: #0000ff;">this</span>.init.apply(<span style="color: #0000ff;">this</span><span style="color: #000000;">, arguments);
</span><span style="color: #008080;">25</span> <span style="color: #000000;">};
</span><span style="color: #008080;">26</span> <span style="color: #008000;">//</span><span style="color: #008000;">发生继承关系，可能为空类</span>
<span style="color: #008080;">27</span> newClass.prototype = <span style="color: #0000ff;">new</span><span style="color: #000000;"> supClass();
</span><span style="color: #008080;">28</span> 
<span style="color: #008080;">29</span> <span style="color: #008000;">//</span><span style="color: #008000;">新建类必定会包含初始化函数，要么继承，如果没继承，这里也会新建</span>
<span style="color: #008080;">30</span> <span style="color: #0000ff;">var</span> supInit = newClass.prototype.init || <span style="color: #0000ff;">function</span><span style="color: #000000;"> () { };
</span><span style="color: #008080;">31</span> <span style="color: #008000;">//</span><span style="color: #008000;">传入的子对象可能包含他的初始化方法，如果有一定要使用，至于父类使用与否看子类心情</span>
<span style="color: #008080;">32</span> <span style="color: #0000ff;">var</span> childInit = childAttr.init || <span style="color: #0000ff;">function</span><span style="color: #000000;"> () { };
</span><span style="color: #008080;">33</span> <span style="color: #008000;">//</span><span style="color: #008000;">父类的properys方法便是指定会具有哪些属性，一定会执行</span>
<span style="color: #008080;">34</span> <span style="color: #0000ff;">var</span> _supAttr = newClass.prototype._propertys_ || <span style="color: #0000ff;">function</span><span style="color: #000000;"> () { };
</span><span style="color: #008080;">35</span> <span style="color: #008000;">//</span><span style="color: #008000;">子类的初始化也一定会触发，先执行父类再执行子类</span>
<span style="color: #008080;">36</span> <span style="color: #0000ff;">var</span> _childAttr = childAttr._propertys_ || <span style="color: #0000ff;">function</span><span style="color: #000000;"> () { };
</span><span style="color: #008080;">37</span> 
<span style="color: #008080;">38</span> <span style="color: #008000;">//</span><span style="color: #008000;">为新建类（可能继承可能新建）初始化原型，上面的会重写，没有就不管他</span>
<span style="color: #008080;">39</span> <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> k <span style="color: #0000ff;">in</span><span style="color: #000000;"> childAttr) {
</span><span style="color: #008080;">40</span> childAttr.hasOwnProperty(k) &amp;&amp; (newClass.prototype[k] =<span style="color: #000000;"> childAttr[k]);
</span><span style="color: #008080;">41</span> <span style="color: #000000;">}
</span><span style="color: #008080;">42</span> 
<span style="color: #008080;">43</span> <span style="color: #008000;">//</span><span style="color: #008000;">处理继承情况</span>
<span style="color: #008080;">44</span> <span style="color: #0000ff;">if</span> (arguments.length &amp;&amp; arguments[0].prototype &amp;&amp; arguments[0].prototype.init ===<span style="color: #000000;"> supInit) {
</span><span style="color: #008080;">45</span> <span style="color: #008000;">//</span><span style="color: #008000;">根据父类重写新建类构造时会用到的方法</span>
<span style="color: #008080;">46</span> newClass.prototype.init = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
</span><span style="color: #008080;">47</span> <span style="color: #0000ff;">var</span> scope = <span style="color: #0000ff;">this</span><span style="color: #000000;">;
</span><span style="color: #008080;">48</span> <span style="color: #0000ff;">var</span> args = [<span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
</span><span style="color: #008080;">49</span> <span style="color: #008000;">//</span><span style="color: #008000;">第一个参数为父类的初始化函数，执行与否看子类心情</span>
<span style="color: #008080;">50</span> <span style="color: #000000;">supInit.apply(scope, arguments)
</span><span style="color: #008080;">51</span> <span style="color: #000000;">} ];
</span><span style="color: #008080;">52</span> <span style="color: #000000;">childInit.apply(scope, args.concat(slice.call(arguments)));
</span><span style="color: #008080;">53</span> <span style="color: #000000;">};
</span><span style="color: #008080;">54</span> <span style="color: #000000;">}
</span><span style="color: #008080;">55</span> <span style="color: #008000;">//</span><span style="color: #008000;">前面说到的，父类与子类的初始化方法一定会执行，先父后子</span>
<span style="color: #008080;">56</span> newClass.prototype._propertys_ = <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
</span><span style="color: #008080;">57</span> _supAttr.call(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;">58</span> _childAttr.call(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;">59</span> <span style="color: #000000;">};
</span><span style="color: #008080;">60</span> 
<span style="color: #008080;">61</span> <span style="color: #008000;">//</span><span style="color: #008000;">成员属性也得继承</span>
<span style="color: #008080;">62</span> <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> k <span style="color: #0000ff;">in</span><span style="color: #000000;"> supClass) {
</span><span style="color: #008080;">63</span> supClass.hasOwnProperty(k) &amp;&amp; (newClass[k] =<span style="color: #000000;"> supClass[k]);
</span><span style="color: #008080;">64</span> <span style="color: #000000;">}
</span><span style="color: #008080;">65</span> <span style="color: #0000ff;">return</span><span style="color: #000000;"> newClass;
</span><span style="color: #008080;">66</span> };</pre>
</div>
<p><span style="line-height: 1.5;">下面我们创建两个类，订单类Order与客户类Customer，其中Order引用了Customer，Customer没有引用Order</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> Order=<span style="color: #000000;"> base.Class({
_propertys_: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
</span><span style="color: #0000ff;">this</span>.customer =<span style="color: #000000;"> {};
},
getCustomer: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.customer;
},
setCustomer: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (arg) {
</span><span style="color: #0000ff;">this</span>.customer =<span style="color: #000000;"> arg;
}
});
</span><span style="color: #0000ff;">var</span> Customer =<span style="color: #000000;"> base.Class({
_propertys_: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
</span><span style="color: #0000ff;">this</span>.orders =<span style="color: #000000;"> {};
}
});</span></pre>
</div>
<p><span style="line-height: 1.5;">现在我们需要决定哪一个类负责控制关联关系，我们这里让单个类来操控，因为这样就可以将所有处理关联关系的逻辑安置到一地：</span></p>
<p>① 如果两者都是引用对象，而其间的关联为&ldquo;一对多&rdquo;关系，那么就由拥有单一引用的那一方承担控制者角色<br>本例中，一个客户可能拥有多个订单，就由Order承担控制者角色<br>② 如果某个对象是组成另一个对象的部件，那么由后者负责关联关系<br>③ 如果两者都是引用对象，其间是多对多关系，那么就随便了</p>
<p>本例中，由于Order负责关联关系，所以我们为Customer添加一个辅助函数，让Order可以直接访问订单集合<br>order的修改函数将使用这个辅助函数对指针两端对象进行同步控制<br>现在，我们改变函数时候，需要同时更新反向指针</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> Order =<span style="color: #000000;"> base.Class({
_propertys_: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
</span><span style="color: #0000ff;">this</span>.customer =<span style="color: #000000;"> {};
},
getCustomer: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.customer;
},
setCustomer: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (arg) {
</span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.customer != <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">this</span>.customer.friendOrders().remove(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">this</span>.customer =<span style="color: #000000;"> arg;
</span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.customer != <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">this</span>.customer.friendOrders().add(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
}
});
</span><span style="color: #0000ff;">var</span> Customer =<span style="color: #000000;"> base.Class({
_propertys_: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
</span><span style="color: #0000ff;">this</span>.orders =<span style="color: #000000;"> {};
},
friendOrders: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.orders;
}
});</span></pre>
</div>
<p><span style="line-height: 1.5;">PS：这段代码我看的也蛋疼，以下是这段蛋疼代码的蛋疼解释</span></p>
<p>类之间关系是各式各样的，因此修改函数的代码也会随之有所差异，如果_customer的值不是null，那么可以拿掉上述第一个null检查<br>但仍然需要检查传入参数是否为null，不过基本形式总是相同：先让对方删除指向你的指针，再将你的指针指向一个新对象，最后将那个新对象指针给自己<br>PS：这一段我没搞懂......<br>将双向关联改为单项关联与上述相反，我这里就不管他了，反正也看不懂</p>
<h1>以字面常量取代魔法数</h1>
<p>我们有一个字面常量，并且带有特别含义<br>那么创造一个常量，根据其意义为他命名，并将上述的字面数值替换为这个常量</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> potentialEnergy(mass, height) {
</span><span style="color: #008080;">2</span> <span style="color: #0000ff;">return</span> mass * 9.81 *<span style="color: #000000;"> height;
</span><span style="color: #008080;">3</span> <span style="color: #000000;">}
</span><span style="color: #008080;">4</span> <span style="color: #0000ff;">var</span> GRAVITATIONAL = 9.81<span style="color: #000000;">;
</span><span style="color: #008080;">5</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> potentialEnergy(mass, height) {
</span><span style="color: #008080;">6</span> <span style="color: #0000ff;">return</span> mass * GRAVITATIONAL *<span style="color: #000000;"> height;
</span><span style="color: #008080;">7</span> }</pre>
</div>
<p><span style="line-height: 1.5;">这个比较简单，我们直接跳过了</span></p>
<h1>封装集合</h1>
<p>有个函数返回一个集合，让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合的函数</p>
<p>我们常常会在类中使用集合来保存一组实例，这样的类通常也会提供针对该集合的取值/设值函数<br>但是，集合的处理方式应该和其它种类数据略有不同，取值函数不该返回集合自身，因为这会让用户得以修改集合内容而拥有者一无所知<br>这样会对用户暴露过多的内部信息。<br>如果一个取值函数确实需要返回多个值，他应该避免用户之间操作对象内所保存的集合，并隐藏对象内存与用户无关的数据结构<br>另外，不应该为整个集合提供一个设值函数，但应该提供添加/移除函数，这样集合拥有者就可以控制集合元素的增删</p>
<h3>怎么做</h3>
<p>① 加入为集合添加/删除元素的函数<br>② 将保存集合的字段初始化为一个空集合<br>③ 找出集合设值函数的所有调用者，可以修改那个设值函数，让他使用新增的添加删除函数，也可以直接修改调用端，改用添加/删除函数<br>两种情况下需要用到集合设值函数：集合为空；准备将原有集合替换为另一集合<br>④ 找出所有通过取值函数获得集合并修改其内容的函数，逐一修改这些函数，将他们改用添加/删除函数<br>⑤ 修改完上述函数后，修改取值函数自身，使他返回集合的一个只读副本<br>⑥ 找出取值函数的所有用户，从中找出应该存于集合所属对象的代码，将这些代码移入宿主对象<br>⑦ 修改现有取值函数的名字，然后添加一个新取值函数，使其返回一个枚举，找出旧取值函数的所有被调用点改为新的</p>
<p>这里来一个例子吧：<br>假如有人要去上课，我们用一个简单的Course来表示课程<br>我们不关心课程细节，我们关心表示人的Person</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> Course =<span style="color: #000000;"> base.Class({
_propertys_: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
</span><span style="color: #0000ff;">this</span>.customer =<span style="color: #000000;"> {};
},
init: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (name, isAdvanced) { },
isAdvanced: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () { }
});
</span><span style="color: #0000ff;">var</span> Person =<span style="color: #000000;"> base.Class({
_propertys_: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
</span><span style="color: #0000ff;">this</span>.courses =<span style="color: #000000;"> {};
},
getCourses: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.courses;
},
setCourses: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (arg) {
</span><span style="color: #0000ff;">this</span>.courses =<span style="color: #000000;"> arg;
}
});</span></pre>
</div>
<p>有了这个我们可以为某人添加课程</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> p = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Person();
</span><span style="color: #0000ff;">var</span> s =<span style="color: #000000;"> [];
s.push(</span><span style="color: #0000ff;">new</span> Course('金X瓶X梅', <span style="color: #0000ff;">false</span><span style="color: #000000;">));
s.push(</span><span style="color: #0000ff;">new</span> Course('痴情关上观痴情', <span style="color: #0000ff;">true</span><span style="color: #000000;">));
p.setCourses(s);</span><span style="color: #008000;">//</span><span style="color: #008000;">size 2</span>
<span style="color: #000000;">console.log(p.getCourses());
</span><span style="color: #0000ff;">var</span> refact = <span style="color: #0000ff;">new</span> Course('不再含苞待放的日子', <span style="color: #0000ff;">true</span><span style="color: #000000;">)
p.getCourses().push(refact);
p.getCourses().push(</span><span style="color: #0000ff;">new</span> Course('后庭花下会后庭', <span style="color: #0000ff;">true</span><span style="color: #000000;">));
console.log(p.getCourses());</span><span style="color: #008000;">//</span><span style="color: #008000;"> size 4</span>
<span style="color: #000000;">p.getCourses().pop();
console.log(p.getCourses());</span><span style="color: #008000;">//</span><span style="color: #008000;"> size 3</span>

<span style="color: #008000;">//</span><span style="color: #008000;">如果想了解高级课程可以这样做：</span>
<span style="color: #0000ff;">var</span> count = 0
<span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = 0, len = p.getCourses().length; i &lt; len; i++<span style="color: #000000;">) {
 </span><span style="color: #0000ff;">if</span> (p.getCourses()[i].isAdvanced()) count++<span style="color: #000000;">;
}

我们要做的第一件事就是为person中的集合添加合适的修改函数：
</span><span style="color: #0000ff;">var</span> Person =<span style="color: #000000;"> base.Class({
 _propertys_: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
 </span><span style="color: #0000ff;">this</span>.courses =<span style="color: #000000;"> [];
 },
 getCourses: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
 </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.courses;
 },
 initCourses: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (arg) {
 </span><span style="color: #0000ff;">this</span>.courses =<span style="color: #000000;"> arg;
 </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = 0, len = arg.length; i &lt; len; i++<span style="color: #000000;">) {
 </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.addCourse(arg[i]);
 }
 },
 addCourse: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (arg) {
 </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.courses.push(arg);
 },
 remove: </span><span style="color: #0000ff;">function</span><span style="color: #000000;"> (arg) {
 </span><span style="color: #008000;">//</span><span style="color: #008000;">显然这个代码毫无意义，权当此处数组可以这样删除吧</span>
<span style="color: #0000ff;">this</span><span style="color: #000000;">.courses.remove(arg)
 }
});</span></pre>
</div>
<p>现在，我们求高级课程的数量的代码就可以移入Person类了</p>
<h1>结语</h1>
<p>该篇文章对上一章进行说明</p>
<p>&nbsp;</p>
                </div>

                <div class='span3 sidebar'>
                    <h2>导航栏</h2>
                    <ul class="nav nav-tabs nav-stacked">
                             				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptzdyxhxzsdyjxyzyddf/index.html">javascript中的一些核心知识点以及需要注意的地方</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/[zd]webappdyhzlyzydqdyhdpyjlkkb/index.html">[置顶]【webapp的优化整理】要做移动前端优化的朋友进来看看吧</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/[zd]yddjrwtyjjavascriptsjjzxjsjydjr/index.html">[置顶]【移动端兼容问题研究】javascript事件机制详解（涉及移动兼容）</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/gruntzhb30fzxhsygruntdbqddm/index.html">【grunt整合版】30分钟学会使用grunt打包前端代码</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/gruntdyd30fzxhsygruntdbqddm/index.html">【grunt第一弹】30分钟学会使用grunt打包前端代码</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/gruntdsdgruntzqdsjxmzdyy/index.html">【grunt第三弹】grunt在前端实际项目中的应用</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/gruntded30fzxhsygruntdbqddm02/index.html">【grunt第二弹】30分钟学会使用grunt打包前端代码（02）</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/IScrollsrxxtpyddhadlqs/index.html">【IScroll深入学习】突破移动端黑暗的利器（上）</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/IScrollsrxxjjIScrollynzz/index.html">【IScroll深入学习】解决IScroll疑难杂症</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/iScrollymxx00mniScroll/index.html">【iScroll源码学习00】模拟iScroll</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/iScrollymxx01zbjd/index.html">【iScroll源码学习01】准备阶段</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/iScrollymxx02fjiScrollsghxsjd/index.html">【iScroll源码学习02】分解iScroll三个核心事件点</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/iScrollymxx03iScrollsjjzygdtdsx/index.html">【iScroll源码学习03】iScroll事件机制与滚动条的实现</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/iScrollymxx04flIScrollhx/index.html">【iScroll源码学习04】分离IScroll核心</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptpxdytyyjc/index.html">【javascript培训第一天】语言基础</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptpxdstcybl/index.html">【javascript培训第三天】查遗补漏</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptpxdetDOMyBOM/index.html">【javascript培训第二天】DOM与BOM</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptjzdsk01mkhbc/index.html">【javascript激增的思考01】模块化编程</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptjzdsk02mkhyMVC/index.html">【javascript激增的思考02】模块化与MVC</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptjzdsk03MVVMyKnockout/index.html">【javascript激增的思考03】MVVM与Knockout</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptjzdsk04MVCyBackbonejs(beta)/index.html">【javascript激增的思考04】MVC与Backbonejs(beta)</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/javascriptmxdxzlrwmyqltkdzb01/index.html">【javascript面向对象之路】让我们一起来坦克大战吧01</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/NodeJSxxbj04xwfbxt/index.html">【NodeJS学习笔记04】新闻发布系统</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/requireJSymxx01ljzgrequireJSdjg/index.html">【requireJS源码学习01】了解整个requireJS的结构</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/requireJSymxx02datamainjzdsx/index.html">【requireJS源码学习02】datamain加载的实现</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/requireJSymxx03xjrequireJSdjzlc/index.html">【requireJS源码学习03】细究requireJS的加载流程</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/UIcjkfygjdrlcjs/index.html">【UI插件】开发一个简单日历插件（上）</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/UIcjjddrlcjxxxMVCsx/index.html">【UI插件】简单的日历插件（下）——学习MVC思想</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zeptoxxbj01hxff$()/index.html">【zepto学习笔记01】核心方法$()</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zeptoxxbj01hxff$()b/index.html">【zepto学习笔记01】核心方法$()（补）</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zeptoxxbj02lsd/index.html">【zepto学习笔记02】零碎点</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zeptoxxbj03sjjz/index.html">【zepto学习笔记03】事件机制</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ycmsztjavascriptzdjc/index.html">【一次面试】再谈javascript中的继承</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ztbackbone01mxModel/index.html">【再探backbone01】模型Model</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ztbackbone02jhCollection/index.html">【再探backbone02】集合Collection</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ztbackbone03bkydyyysltgym/index.html">【再探backbone03】博客园单页应用实例（提供源码）</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ztbackbone04dyyydjslycl/index.html">【再探backbone04】单页应用的基石路由处理</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ctUnderscorezsmbyq/index.html">【初探Underscore】再说模版引擎</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ckjavascriptamzAjaxjsxnszddAjax/index.html">【初窥javascript奥秘之Ajax】简述下你所知道的Ajax？</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ckjavascriptamzsjmpnxnwmyqmdp/index.html">【初窥javascript奥秘之事件冒泡】那些年我们一起冒的泡</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ckjavascriptamzsjjzldtygdj/index.html">【初窥javascript奥秘之事件机制】论“点透”与“鬼点击”</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ckjavascriptamzrrzmbddthisnzdxzthiszxnlm/index.html">【初窥javascript奥秘之让人捉摸不定的this】你知道现在this指向哪里吗？？？</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ckjavascriptamzbbydxbdhlqbcl/index.html">【初窥javascript奥秘之闭包】叶大侠病都好了，求不踩了：）</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ckjavascriptamzmxdxfzyjc/index.html">【初窥javascript奥秘之面向对象】封装与继承</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/qdmdsjdjgjdnzdljm/index.html">【前端盲点】事件的几个阶段你真的了解么？？？</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dyyyviewymodelxgsl/index.html">【单页应用】view与model相关梳理</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dyyyyqldyyybsxjdwbgns/index.html">【单页应用】一起来单页应用吧，实现简单微博功能！（上）</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dyyyqjkzqappyggxsm/index.html">【单页应用】全局控制器app应该干些什么？</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dyyywmgrhclkjdcccjgx/index.html">【单页应用】我们该如何处理框架弹出层层级关系？</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dyyyljMVC/index.html">【单页应用】理解MVC</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dyyyztxjzviewzjygrhtx/index.html">【单页应用之通信机制】view之间应该如何通信</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dyyyjkzHistoryxsHistorydgdyyydm/index.html">【单页应用巨坑之History】细数History带给单页应用的噩梦</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/xtszeptofindysyjiosdcjpknrnhtt/index.html">【小贴士】zeptofind元素以及ios弹出键盘可能让你很头疼</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/xtsgytransitionEndanimatedygyqgs/index.html">【小贴士】关于transitionEndanimate的一个有趣故事</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/xtsgzzdbbysjwtdzzmp/index.html">【小贴士】工作中的”闭包“与事件委托的”阻止冒泡“</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/xtstytjavascriptzdreplace/index.html">【小贴士】探一探javascript中的replace</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/xtsxnjpyfixeddgydddt/index.html">【小贴士】虚拟键盘与fixed带给移动端的痛！</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ttjavascriptsjjzdcsxyl/index.html">【探讨】javascript事件机制底层实现原理</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/mkhbcljrequireJSsxygjddmkjzq/index.html">【模块化编程】理解requireJS实现一个简单的模块加载器</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zyJavaScriptmfjmtsdqlxkjzbfgndcljz/index.html">【转】【译】JavaScript魔法揭秘探索当前流行框架中部分功能的处理机制</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zxjavascriptgszl01javascriptcszds/index.html">【追寻javascript高手之路01】javascript参数知多少？</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zxjavascriptgszl02blzyyzds/index.html">【追寻javascript高手之路02】变量、作用域知多少？</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zxjavascriptgszl03javascriptdxdld/index.html">【追寻javascript高手之路03】javascript对象大乱斗</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zxjavascriptgszl04ljprototype/index.html">【追寻javascript高手之路04】理解prototype</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zxjavascriptgszl05ljsjl/index.html">【追寻javascript高手之路05】理解事件流</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zgbj04zxzzsj(2)/index.html">【重构笔记04】重新组织数据(2)</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zgbj05jhtjbds/index.html">【重构笔记05】简化条件表达式</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/zgbj06jhhsdy/index.html">【重构笔记06】简化函数调用</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ycmshgttbxysjfl/index.html">一次面试回顾——探讨表现与数据分离</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dhzwebappzdxz/index.html">动画在webapp中的现状</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/ysandriodlqhthdomclicksjqtsxwttj/index.html">原生andriod浏览器回退后dom（click）事件全体失效问题探究</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/scsbdjxysdsbsjytouchsjdnxs/index.html">手持设备点击响应速度，鼠标事件与touch事件的那些事</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/mnbjQueryzeptohxymfx/index.html">迷你版jQuery——zepto核心源码分析</a></li>
    				          				<li><a href="http://songboriceboy.github.io/xxoo/html/javascript/dbsgzdlwmlyqxjdddomxzqb/index.html">都别说工资低了，我们来一起写简单的dom选择器吧！</a></li>
    				                                         
                    </ul>
                </div>
            </div>

        </div>
    </body>
</html>